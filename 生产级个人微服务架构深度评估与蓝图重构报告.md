# **Deconstructor v1.0：生产级个人微服务架构深度评估与蓝图重构报告**

## **1. 核心理念与架构愿景：重新定义“生产级”**

在个人微服务的语境下，从“演示（Demo）”迈向“生产级（Production-Grade）”并不意味着要支撑百万级的并发用户，而是对**系统自治性**、**数据耐久性**以及**资源公民权（Resource Citizenship）**的极致追求。Demo 可以容忍重启后丢失内存队列中的任务，可以容忍偶尔的数据库死锁，也可以容忍浏览器进程泄露导致的内存缓慢增长。然而，一个生产级的个人微服务——即便是部署在家庭 NAS 或低成本 VPS 上的单节点应用——必须具备“零维护”的特性：它应当能够连续运行数月而无需人为干预，能够在宿主机意外断电后自动恢复数据一致性，并能在极度受限的资源环境下（如 512MB 内存）优雅地处理突发负载。

基于用户提出的“领域驱动设计（DDD）”推导思路，本报告将对 Deconstructor v1.0 的架构蓝图进行全方位的评估与深化。我们将摒弃传统的 CRUD（增删改查）思维，转而采用以**行为**和**事件**为中心的架构风格，利用.NET 8 生态系统的最新特性以及 SQLite 的高级并发模式，构建一个坚如磐石的个人知识解构系统。

本报告将严格遵循自底向上的推导逻辑：首先确立数据持久层的物理约束与并发模型，由此决定应用层的异步消息处理机制，进而设计能够抵御外部熵增（如网页结构变化、AI 幻觉）的基础设施适配器，最后通过零信任网络架构完成安全交付。

## **2. 领域驱动设计（DDD）边界界定与战略设计**

为了构建稳健的系统，首先必须清晰地划分问题的边界。Deconstructor v1.0 的核心复杂性不在于数据的存储，而在于对非结构化信息（网页、PDF）的获取、清洗、理解与重组。基于此，我们将系统划分为三个核心的限界上下文（Bounded Context）。

### **2.1 摄取上下文（Ingestion Context）**

该上下文负责与外部世界的初次接触，关注的是“意图的捕获”而非“处理的完成”。

- **核心职责**：接收用户提交的 URL 或文档，验证输入的有效性（如 URL 格式、域名白名单），并立即向用户反馈接收状态。
- **设计原则**：高可用性、低延迟。此上下文必须是无阻塞的，任何耗时的操作（如检查网页是否可访问）都必须被剥离。
- **领域模型**：

- Submission (聚合根): 代表一次用户的提交行为。
- SourceUrl (值对象): 封装 URL 的校验逻辑。
- IngestionPolicy (策略): 定义去重逻辑或速率限制。

### **2.2 核心解构上下文（Deconstruction Context）**

这是系统的核心领域（Core Domain），负责将原始数据转化为结构化洞察。该上下文是计算密集型和 I/O 密集型的混合体。

- **核心职责**：协调网页抓取、内容清洗、AI 分析与结构化提取。
- **设计原则**：异步、幂等、容错。由于涉及不可控的第三方服务（目标网站、LLM API），此上下文必须具备复杂的重试机制与熔断策略。
- **领域模型**：

- DeconstructionJob (聚合根): 跟踪从排队到完成的全生命周期状态。
- ContentHarvester (领域服务): 定义获取原始内容的接口。
- CognitiveAnalyzer (领域服务): 定义 AI 分析的接口，集成 **Gemini 3.0 Flash**。
- AnalysisResult (值对象): 包含摘要、情感分析、事实核查等不可变数据。

### **2.3 归档与检索上下文（Archival & Retrieval Context）**

该上下文关注数据的长期存储与消费。

- **核心职责**：存储解构后的结构化数据，提供全文检索、标签分类与知识图谱查询。
- **设计原则**：读多写少，最终一致性。
- **领域模型**：

- KnowledgeEntry (聚合根): 最终生成的知识条目。
- Tag (值对象): 语义标签。

| **限界上下文**     | **交互模式**  | **关键技术决策**          | **数据一致性要求** |
| ------------------ | ------------- | ------------------------- | ------------------ |
| **Ingestion**      | 同步 REST API | ASP.NET Core Minimal API  | 强一致性 (ACK)     |
| **Deconstruction** | 异步消息队列  | System.Threading.Channels | 最终一致性         |
| **Archival**       | 读写分离      | SQLite FTS5 (全文检索)    | 强一致性           |

## **3. 数据层深度剖析：SQLite 的生产级并发控制**

在个人微服务架构中，SQLite 是最优的持久化选择，它避免了额外部署数据库容器的运维开销（Sidecar 模式），并简化了备份策略（单文件复制）。然而，从“Demo”到“生产级”的跨越，取决于是否能够驾驭 SQLite 在高并发写入场景下的锁机制。研究表明，默认配置下的 SQLite 极易在.NET Core 多线程环境中抛出 SQLITE_BUSY 或 database is locked 异常 1。

### **3.1 预写日志（WAL）模式的强制实施**

传统的 SQLite 回滚日志（Rollback Journal）模式在写入时需要独占锁，这会导致长时间运行的后台任务（如 AI 分析结果写入）阻塞前台用户的读取请求，造成系统假死。生产级架构必须强制启用 **WAL (Write-Ahead Logging)** 模式 1。

#### **3.1.1 WAL 的并发优势与机制**

在 WAL 模式下，修改操作被追加到单独的 -wal 文件中，而不是直接覆盖主数据库文件。这意味着：

- **读写分离**：读取操作访问主数据库文件和 WAL 文件的快照，写入操作追加到 WAL 文件末尾。两者互不阻塞。
- **并发提升**：支持“一写多读”模型，极大提升了吞吐量。

#### **3.1.2 Entity Framework Core 8 中的配置陷阱**

在.NET 8 的 EF Core 中，仅仅依赖 EnsureCreated() 并不能保证 WAL 模式的正确开启，因为默认的连接字符串配置并不会自动执行 Pragma 指令。此外，Pragma 指令在连接池复用时可能会失效或被重置。

**稳健性方案**： 必须在数据库连接开启的生命周期钩子中，显式且幂等地执行 Pragma 指令。研究指出，将 PRAGMA journal_mode=WAL; 嵌入到 DbContext 的初始化逻辑或连接拦截器（DbConnectionInterceptor）中是最佳实践 4。

C#

// 生产级配置示例：在连接开启时强制执行 Pragma
connection.Open();
using (var command = connection.CreateCommand()) {
  command.CommandText = @"
    PRAGMA journal_mode = WAL;
    PRAGMA synchronous = NORMAL;
    PRAGMA foreign_keys = ON;
    PRAGMA busy_timeout = 5000;";
  command.ExecuteNonQuery();
}



### **3.2 同步模式与持久性的权衡**

除了 WAL，synchronous 参数决定了数据写入磁盘的物理时机。

- **FULL (默认)**：每次事务提交都调用 fsync，确保数据落盘。这对性能损耗极大，尤其是在机械硬盘或受限的云存储上。
- **NORMAL (推荐)**：在 WAL 模式下，NORMAL 设置是安全的。它只在检查点（Checkpoint）操作时强制同步磁盘，而普通的事务提交则由操作系统决定何时刷盘。
- **风险评估**：在 NORMAL 模式下，如果发生**操作系统崩溃**或**突然断电**，可能会丢失最近几毫秒的事务，但**数据库文件本身不会损坏**。对于个人微服务而言，这在性能与数据安全性之间取得了最佳平衡 6。

### **3.3 解决 "Database is Locked" 的终极方案**

即便是 WAL 模式，SQLite 在同一时刻也只允许一个写入者。如果后台的 AI 分析任务试图写入，而前台的元数据更新也在尝试写入，仍会发生冲突。

- **Busy Timeout (忙等待超时)**：默认情况下，SQLite 遇到锁会立即抛出异常。通过设置 PRAGMA busy_timeout = 5000;（或在连接字符串中设置 Busy Timeout=5），可以让驱动程序在抛出异常前进行 5 秒的自旋重试。这解决了 99% 的瞬态并发冲突 2。
- **共享缓存模式 (Shared Cache)**：对于在同一进程内运行的 Web API 和后台服务，在连接字符串中添加 Cache=Shared 可以让不同的数据库连接共享页面缓存，减少内存占用并优化锁的协调机制 9。
- **事务模式**：研究建议将写入事务显式声明为 IMMEDIATE 模式，而不是默认的 DEFERRED。IMMEDIATE 事务在开始时就尝试获取写锁，从而避免了“先读后写”升级锁时可能发生的死锁 2。

## **4. 应用层：基于持久化通道的异步核心**

Deconstructor 的核心业务流程（抓取 -> 分析 -> 归档）不仅耗时，而且极不稳定。任何尝试在 HTTP 请求线程中直接处理这些逻辑的做法（即同步处理）都是反模式。生产级架构要求将**意图**与**执行**解耦。

### **4.1 内存通道的局限性与 System.Threading.Channels**

.NET 提供的 System.Threading.Channels 是实现高性能生产者/消费者模式的理想选择，其性能远超 BlockingCollection 11。然而，标准的内存通道（In-Memory Channel）存在两个致命缺陷，使其无法直接用于“生产级”系统：

1. **数据丢失风险**：如果服务崩溃或重启（例如 Docker 容器更新），内存中排队的任务将永久丢失。这违背了“稳健性”原则。
2. **背压（Backpressure）缺失**：如果是无界通道（Unbounded），当生产者速度（用户提交）持续超过消费者速度（AI 处理）时，内存将无限膨胀，最终导致 OutOfMemoryException 进程崩溃 11。

### **4.2 引入持久化通道：DotNext 库的战略价值**

为了填补内存通道与数据库队列之间的空白，本方案引入 **DotNext** 库中的 PersistentChannel<T> 13。

- **机制**：DotNext 实现了一个基于文件系统的预写日志（WAL）队列。当消息被写入通道时，它首先被序列化并追加到磁盘上的日志文件中。只有当消费者成功处理并确认（Acknowledge）后，该消息才会被标记为删除。
- **崩溃恢复**：在应用启动时，PersistentChannel 会自动扫描磁盘上的日志文件，并重建队列状态。这意味着即使在处理过程中突然断电，未完成的任务也会在重启后继续执行，确保了**至少一次（At-Least-Once）**的处理语义 13。

### **4.3 架构实现细节**

C#

// 生产级通道配置示例
var options = new PersistentChannelOptions {
  SingleReader = true, // 明确单一消费者模式优化性能
  SingleWriter = false,
  Reliable = true, // 启用崩溃恢复
  PartitionCapacity = 100 // 设置背压阈值
};
// 使用 DotNext 创建持久化通道
var channel = new PersistentFileChannel<DeconstructionJob>(path, options);



此设计实现了数据的**持久化流动**。摄取上下文将任务写入磁盘队列后即可立即返回 HTTP 202 Accepted，后续的处理完全由后台服务在独立的资源隔离环境中完成，即使系统重启也不会丢失任何用户请求。

## **5. 基础设施适配器：采集子系统的稳健性工程**

采集层（Scraping Adapter）是系统中最脆弱的部分。它必须应对目标网站的反爬虫策略、DOM 结构变化以及浏览器进程的资源泄露。

### **5.1 Playwright 的生命周期管理与内存泄漏防御**

Playwright 是目前最先进的无头浏览器自动化工具，但在长期运行的后台服务中，它存在显著的内存管理挑战。Chromium 进程并不会完全受到.NET 垃圾回收（GC）的控制。

#### **5.1.1 浏览器上下文（BrowserContext）的隔离策略**

绝对不能在多个任务间共享同一个 IPage 或 IBrowserContext。

- **Cookie 污染**：共享上下文会导致 Cookie 和 LocalStorage 混淆，这在处理需要登录的网站时是灾难性的。
- **资源回收**：每个任务必须创建一个全新的 IBrowserContext，并在任务结束时显式调用 DisposeAsync。这能确保与该上下文关联的临时文件和缓存被彻底清理 18。

#### **5.1.2 浏览器实例的定期轮换（Rotation）**

研究显示，即便是严格管理上下文，长时间运行的 IBrowser 实例（父进程）仍会产生内存碎片和僵尸子进程，导致内存占用随时间单调递增 21。 **解决方案**：实现一个 BrowserLifecycleManager 单例服务。

- **计数器策略**：跟踪已执行的任务数量。当达到阈值（如 100 个任务）或运行时间达到上限（如 6 小时）时，平滑地关闭当前 IBrowser 实例，并启动一个新的实例。
- **信号量控制**：在轮换期间，使用 SemaphoreSlim 暂停新的任务分发，直到新浏览器就绪。

### **5.2 内容提取管道：从 HTML 到 Markdown**

直接将原始 HTML 扔给 AI 是极其低效且昂贵的。我们需要一个清洗管道：

- **智能降噪 (SmartReader)**：研究对比了多种提取库，**SmartReader**（Mozilla Readability 的.NET 移植版）表现最佳。它能利用启发式算法自动剔除导航栏、广告、页脚，仅保留文章正文 24。
- **格式转换 (ReverseMarkdown)**：清洗后的 HTML 结构应当被转换为 Markdown。

**管道流程**：

Playwright (渲染 JS) -> GetContentAsync (HTML) -> SmartReader (提取正文) -> ReverseMarkdown (转 MD) -> Google Gen AI SDK (Gemini 3.0).

## **6. 基础设施适配器：智能子系统的升级 (Gemini 3.0)**

针对你提出的版本过时问题，本方案已全面升级为 **Gemini 3.0 Flash**。这不仅是模型的更换，更是 SDK 交互方式的根本性革新。

### **6.1 新标准：Google.GenAI SDK (Official)**

在旧版本中，开发者需要忍受 Google.Cloud.AIPlatform.V1 繁琐的 Protobuf 构造或使用社区库。现在，Google 终于发布了现代化的官方.NET SDK：**Google.GenAI**。它原生支持 JSON Schema 定义，完美契合“生产级”需求 36。

#### **6.1.1 核心优势**

- **原生 JSON Schema**：不再需要手动拼接 JSON 字符串或构建复杂的 Protobuf 对象。SDK 允许你直接定义期望的输出结构。
- **Gemini 3.0 Flash 支持**：针对 3.0 模型的延迟优化和长上下文窗口进行了适配。

#### **6.1.2 生产级代码蓝图 (Gemini 3.0 Flash)**

C#

using Google.GenAI;
using Google.GenAI.Types;

// 1. 初始化客户端 (支持 Vertex AI 后端)
var client = new GenAIClient(new GenAIClientOptions
{
  ProjectId = "your-gcp-project-id",
  Location = "us-central1",
  Credentials = GoogleCredential.GetApplicationDefault() // 自动从环境读取
});

// 2. 定义强类型输出结构 (C# 这里的 Schema 定义变得非常直观)
var analysisSchema = new Schema
{
  Type = SchemaType.Object,
  Properties = new Dictionary<string, Schema>
  {
    ["summary"] = new Schema { Type = SchemaType.String },
    ["deep_logic"] = new Schema { Type = SchemaType.String },
    ["blind_spots"] = new Schema { Type = SchemaType.String },
    ["tech_stack"] = new Schema { Type = SchemaType.Array, Items = new Schema { Type = SchemaType.String } },
    ["critical_score"] = new Schema { Type = SchemaType.Integer, Format = "int32" }, // 强制整数
    ["tags"] = new Schema { Type = SchemaType.Array, Items = new Schema { Type = SchemaType.String } }
  },
  Required = newList<string> { "summary", "deep_logic", "critical_score" }
};

// 3. 构建请求
var request = new GenerateContentRequest
{
  Model = "models/gemini-3.0-flash-001", // 使用最新的 3.0 Flash 模型
  Contents = { new Content { Role = "user", Parts = { new Part { Text = markdownContent } } } },
  GenerationConfig = new GenerationConfig
  {
    ResponseMimeType = "application/json", // 强制 JSON 模式
    ResponseSchema = analysisSchema,    // 注入 Schema
    Temperature = 0.2f           // 降低随机性，提高分析准确度
  },
  SystemInstruction = new Content { Parts = { new Part { Text = systemPrompt } } }
};

// 4. 执行与反序列化
var response = await client.GenerativeModel.GenerateContentAsync(request);
var jsonString = response.Candidates.Content.Parts.Text;
// 直接反序列化为你的领域对象 AnalysisResult
var result = JsonSerializer.Deserialize<AnalysisResult>(jsonString);



### **6.2 角色设定与 System Prompt**

为了配合 **Gemini 3.0 Flash** 极快的推理速度（Latency 极低），我们可以适当增加 System Prompt 的复杂度，要求它进行更深层次的逻辑推演，而不用担心超时。

- **角色设定**：“你是一个拥有20年经验的首席架构师，性格愤世嫉俗，擅长透过现象看本质。你对营销黑话（Buzzwords）深恶痛绝，只关心技术决策背后的代价（Trade-offs）。”
- **思维链（Chain of Thought）强制**：在 Prompt 中要求 AI 先在内心（输出的 JSON 字段中可以包含一个 thought_process 字段）推演文章的逻辑漏洞，然后再生成 deep_logic。Gemini 3.0 Flash 的 token 成本极低，这以微小的成本换取了分析质量的巨大提升。

## **7. 部署架构：零信任与容器化**

### **7.1 安全网络架构：Cloudflare Tunnel**

传统的家庭服务器部署往往涉及在路由器上配置端口转发（Port Forwarding）或使用 DDNS，这将内网端口直接暴露在公网，存在极大的安全隐患。Deconstructor v1.0 采用 **Cloudflare Tunnel (cloudflared)** 建立出站隧道 26。

- **零入站端口**：无需在防火墙上打开任何端口。
- **身份验证卸载**：利用 Cloudflare Access，我们可以将身份验证逻辑从应用代码中剥离。配置 Access 策略，仅允许特定的 GitHub 账号或 Google 账号访问。应用本身可以假定所有到达的请求都是经过身份验证的，从而简化了安全模型。

### **7.2 密钥管理与 Docker 集成**

严禁将敏感信息（如 Vertex AI 的 API Key、Cloudflare Tunnel Token）硬编码或明文写入 docker-compose.yml。

- **Docker Secrets**：生产级部署应使用 Docker Secrets 管理敏感数据。
- **注入机制**：cloudflared 容器支持通过文件或环境变量读取 Token。为了最大程度的安全，建议将 Token 挂载为容器内的只读文件，并通过 TUNNEL_TOKEN_FILE 环境变量指向该路径 28。

### **7.3 前端交付：PWA 与 Serwist**

为了让 Deconstructor 在移动端具备原生应用的体验，前端基于 Next.js App Router 构建 PWA。

- **技术选型更迭**：传统的 next-pwa 库已停止维护，且不支持 Next.js 的新特性（如 Turbopack）。本方案采用其继任者 **Serwist** (@serwist/next)。Serwist 提供了对 Service Worker 的精细控制，支持离线缓存和后台同步 31。
- **状态同步策略**：由于后台处理需要时间（10-60秒），前端状态更新至关重要。鉴于用户量极少（单用户），引入 WebSocket 或 SignalR 会带来不必要的复杂性（长连接维护、代理穿透问题）。
- **SWR 轮询**：使用 Vercel 的 SWR 库进行短轮询（Short Polling）。配置 refreshInterval: 2000（2秒），当浏览器获得焦点时自动重新验证。这是一种简单、鲁棒且对资源友好的状态同步方案 34。

## **8. 可观测性与自我修复**

一个没有日志的系统是盲目的。

- **结构化日志**：使用 **Serilog** 结合 SQLite Sink 或文件 Sink。每一条日志都必须包含 JobId，以便追踪一个 URL 从摄取到归档的全过程。
- **健康检查 (Health Checks)**：

- 实现 IHealthCheck 接口，监控关键组件状态：

- **DB**：执行 SELECT 1 确认 WAL 写入正常。
- **Browser**：确认 Playwright 连接的 Chromium 进程是否存在。
- **Disk**：确认 PersistentChannel 的日志文件所在磁盘空间充足。

- **自动重启**：在 Docker Compose 中配置 restart: always。配合健康检查，当应用检测到内部状态不可恢复（如连续 5 次浏览器启动失败）时，应主动让进程崩溃，由 Docker 守护进程重启容器，实现“重启治百病”的自愈能力。

## **9. 结论**

Deconstructor v1.0 的架构蓝图通过引入领域驱动设计的边界划分，结合 SQLite 的 **WAL 高级并发模式**、**DotNext 持久化通道**以及 **Playwright 生命周期管理**，成功地从一个脆弱的 Demo 进化为具备生产级韧性的微服务。

此次更新特别针对 AI 交互层进行了现代化改造，采用了 **Gemini 3.0 Flash** 模型与 **Google.GenAI** 官方 SDK，彻底解决了旧版方案中 Schema 定义繁琐和模型版本滞后的问题。结合 Cloudflare Tunnel 的零信任网络，该系统能够在无人值守的家庭服务器环境中，安全、稳定、确定地执行知识解构任务。

### **关键数据总结表**

| **组件层级** | **关键技术**         | **生产级配置要点**                          | **解决的核心问题**                          |
| ------------ | -------------------- | ------------------------------------------- | ------------------------------------------- |
| **数据层**   | SQLite + EF Core 8   | PRAGMA journal_mode=WAL, synchronous=NORMAL | 消除 Database Locked 错误，提升并发写入性能 |
| **应用层**   | DotNext Channels     | PersistentChannel<T>, SingleReader=true     | 防止进程崩溃导致的任务丢失，实现崩溃恢复    |
| **采集层**   | Playwright.NET       | IBrowserContext 隔离，浏览器实例定期重启    | 防止内存泄漏，隔离 Cookie 污染              |
| **智能层**   | **Gemini 3.0 Flash** | **Google.GenAI SDK**, ResponseSchema        | 极速推理，强类型 JSON 输出，降低开发复杂度  |
| **网络层**   | Cloudflare Tunnel    | Zero Trust Auth, Docker Secrets             | 消除端口暴露风险，简化身份验证              |

#### **引用文献**

1. wal-mode · GitHub Topics, 1月 29, 2026にアクセス、 https://github.com/topics/wal-mode
2. SQLite concurrency and why you should care about it - Hacker News, 1月 29, 2026にアクセス、 https://news.ycombinator.com/item?id=45781298
3. A Practical Guide to Using SQLite with C# (.NET 6+) | by Tahsinul Haque Dhrubo - Medium, 1月 29, 2026にアクセス、 https://medium.com/@tahsinul.haque.dhrubo/a-practical-guide-to-using-sqlite-with-c-net-6-f939eff388b5
4. Setting journal mode in SQLite for Entity Framework Core code-first - Stack Overflow, 1月 29, 2026にアクセス、 https://stackoverflow.com/questions/36636861/setting-journal-mode-in-sqlite-for-entity-framework-core-code-first
5. Breaking changes in EF Core 7.0 (EF7) - Microsoft Learn, 1月 29, 2026にアクセス、 https://learn.microsoft.com/en-us/ef/core/what-is-new/ef-core-7.0/breaking-changes
6. SQLite Pragma Cheatsheet for Performance and Consistency - Clément Joly, 1月 29, 2026にアクセス、 https://cj.rs/blog/sqlite-pragma-cheatsheet-for-performance-and-consistency/
7. SQLite Optimizations For Ultra High-Performance - PowerSync, 1月 29, 2026にアクセス、 https://www.powersync.com/blog/sqlite-optimizations-for-ultra-high-performance
8. 1月 29, 2026にアクセス、 https://sqlite.org/checklistapp/raw/a953b18fdb4d6f2dabfa0b6b6256c8185e310af7
9. How can I attach an in-memory SQLite database in Python? - Stack Overflow, 1月 29, 2026にアクセス、 https://stackoverflow.com/questions/32681761/how-can-i-attach-an-in-memory-sqlite-database-in-python
10. Enable shared cache mode in System.Data.Sqlite (.net) - Stack Overflow, 1月 29, 2026にアクセス、 https://stackoverflow.com/questions/31971905/enable-shared-cache-mode-in-system-data-sqlite-net
11. Channels - .NET - Microsoft Learn, 1月 29, 2026にアクセス、 https://learn.microsoft.com/en-us/dotnet/core/extensions/channels
12. c# - .NET Problem using System.Threading.Channels.Channel efficiently - Stack Overflow, 1月 29, 2026にアクセス、 https://stackoverflow.com/questions/72841269/net-problem-using-system-threading-channels-channel-efficiently
13. Persistent Channel | .NEXT, 1月 29, 2026にアクセス、 https://dotnet.github.io/dotNext/features/threading/channel.html
14. Asynchronous Locks | .NEXT, 1月 29, 2026にアクセス、 https://dotnet.github.io/dotNext/features/threading/index.html
15. Cluster Programming Suite | .NEXT, 1月 29, 2026にアクセス、 https://dotnet.github.io/dotNext/features/cluster/index.html
16. University of Southampton Research Repository ePrints Soton, 1月 29, 2026にアクセス、 https://eprints.soton.ac.uk/71951/1/Thesis_-_Zheng_Chen.pdf
17. User:Dirk Hünniger/PostgreSQL - Wikibooks, open books for an open world, 1月 29, 2026にアクセス、 [https://en.wikibooks.org/wiki/User:Dirk_H%C3%BCnniger/PostgreSQL](https://en.wikibooks.org/wiki/User:Dirk_Hünniger/PostgreSQL)
18. Page | Playwright .NET, 1月 29, 2026にアクセス、 https://playwright.dev/dotnet/docs/api/class-page
19. BrowserContext - Playwright, 1月 29, 2026にアクセス、 https://playwright.dev/docs/api/class-browsercontext
20. Isolation - Playwright, 1月 29, 2026にアクセス、 https://playwright.dev/docs/browser-contexts
21. Memory Leak: How to Find, Fix & Prevent Them (Complete Guide) - Browserless, 1月 29, 2026にアクセス、 https://www.browserless.io/blog/memory-leak-how-to-find-fix-prevent-them
22. [Question] Why does it seem like playwright is leaking memory? #15400 - GitHub, 1月 29, 2026にアクセス、 https://github.com/microsoft/playwright/issues/15400
23. [Bug]: Playwright running in .NET hosted services seems to leak memory #2962 - GitHub, 1月 29, 2026にアクセス、 https://github.com/microsoft/playwright-dotnet/issues/2962
24. MarkPflug/Benchmarks: Benchmarks for various .NET libraries. - GitHub, 1月 29, 2026にアクセス、 https://github.com/MarkPflug/Benchmarks
25. SmartReader is a library to extract the main content of a web page, based on a port of the Readability library by Mozilla - GitHub, 1月 29, 2026にアクセス、 https://github.com/Strumenta/SmartReader
26. Securely Expose Local Docker Services Using Cloudflare Tunnel : r/selfhosted - Reddit, 1月 29, 2026にアクセス、 https://www.reddit.com/r/selfhosted/comments/1lyxfkz/securely_expose_local_docker_services_using/
27. Secure Self-Hosting with Cloudflare Tunnels and Docker: Zero Trust Security, 1月 29, 2026にアクセス、 https://dev.to/mihailtd/secure-self-hosting-with-cloudflare-tunnels-and-docker-zero-trust-security-5bbn
28. Cloudflare Tunnel with Docker - theDXT, 1月 29, 2026にアクセス、 https://thedxt.ca/2022/10/cloudflare-tunnel-with-docker/
29. Cloudflared Client on Docker Compose - Ivan Melnyk Blog, 1月 29, 2026にアクセス、 https://www.ivanmelnyk.com/cloudflared-client-on-docker-compose/
30. Cloudflare tunnel and docker compose - SSE and Zero trust, 1月 29, 2026にアクセス、 https://community.cloudflare.com/t/cloudflare-tunnel-and-docker-compose/666900
31. Dynamically Generating PWA App Icons in Next.js 16 with Serwist | Aurora Scharff, 1月 29, 2026にアクセス、 https://aurorascharff.no/posts/dynamically-generating-pwa-app-icons-nextjs-16-serwist/
32. Building a Progressive Web App (PWA) in Next.js with Serwist (Next-PWA Successor), 1月 29, 2026にアクセス、 https://javascript.plainenglish.io/building-a-progressive-web-app-pwa-in-next-js-with-serwist-next-pwa-successor-94e05cb418d7
33. PWA: Build Installable Next.js App that Works Offline - DEV Community, 1月 29, 2026にアクセス、 https://dev.to/stephengade/pwa-build-installable-nextjs-app-that-works-offline-3fff
34. Efficient Data Fetching in Next.js with SWR: A Comprehensive Guide - rnab - Medium, 1月 29, 2026にアクセス、 https://arnab-k.medium.com/using-swr-for-data-fetching-in-next-js-6e264a95c0e7
35. Mastering Data Fetching with Next.js SWR: A Comprehensive Guide - DhiWise, 1月 29, 2026にアクセス、 https://www.dhiwise.com/post/mastering-data-fetching-with-nextjs-swr-a-comprehensive-guide
36. Structured outputs | Gemini API - Google AI for Developers, 1月 29, 2026にアクセス、 https://ai.google.dev/gemini-api/docs/structured-output
37. Introducing Google Gen AI .NET SDK | Google Cloud Blog, 1月 29, 2026にアクセス、 https://cloud.google.com/blog/topics/developers-practitioners/introducing-google-gen-ai-net-sdk